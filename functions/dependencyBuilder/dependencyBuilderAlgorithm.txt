1. Создаем функцию для построения дерева зависимостей
   В качестве параметров - зависимости и функция.
2. Внутри этой функции создаем функцию для отправки запроса (троекратно)
   На каждой итерации обработать ответ от асинхронного запроса
3. функция buildTree рекурсивно строит дерево зависимостей для всех пакетов в dependencies.

Внутри нее:
fetchDependencies(packageName): Эта строка вызывает асинхронную функцию fetchDependencies, которая запрашивает зависимости для пакета packageName. Результат этого запроса сохраняется в переменной dependencies.

if (dependencies.length === 0) return; После получения зависимостей проверяется их количество. Если зависимостей нет (длина массива dependencies равна 0), то функция завершает выполнение и возвращает undefined, так как нет необходимости строить дерево для этого пакета.

for (const dependency of dependencies): Этот цикл проходит по каждой зависимости в массиве dependencies.

if (!subtree[dependency]): Для каждой зависимости проверяется, существует ли уже узел для неё в дереве subtree. Если узел не существует, то создаётся новый пустой узел в дереве subtree с ключом, соответствующим имени зависимости.

subtree[dependency] = {};: Создание нового пустого узла в дереве subtree для текущей зависимости dependency.

await buildTree(dependency, subtree[dependency]): Здесь происходит рекурсивный вызов функции buildTree. Мы передаём в неё имя зависимости и её узел в дереве subtree. Таким образом, для каждой зависимости строится её собственное поддерево, если оно не было построено ранее.

Этот процесс продолжается до тех пор, пока не будут обработаны все зависимости пакета и его подзависимости. Таким образом, функция buildTree рекурсивно строит дерево зависимостей для всех пакетов в dependencies.

4.Создаем константу для хранения имен пакетов. Записываем туда ключи объектов из dependencies
5. Проходимся по всем именам и составляем пары имя: зависимость